1200 100 426416
4200 300 391000
7800 600 770875
12000 1000 964291
19500 1500 1551542
25200 2100 1968000
30800 2800 700417
39600 3600 651042
36000 4500 529917
44000 5500 606000
46200 6600 651792
54600 7800 787333
63700 9100 931500
73500 10500 662083
72000 12000 872709
81600 13600 971167
91800 15300 891333
102600 17100 1374500
114000 19000 1415375
126000 21000 1204500
138600 23100 1684958
151800 25300 1624541
165600 27600 1718500
180000 30000 1843583
195000 32500 2189500
210600 35100 1486000
226800 37800 1827667
203000 40600 1924667
217500 43500 2379500
232500 46500 2995208
248000 49600 2693750
264000 52800 2979334
280500 56100 4027750
297500 59500 3956916
315000 63000 4567750
333000 66600 5053542
351500 70300 5384875
370500 74100 4565375
390000 78000 7155750
410000 82000 8413083
430500 86100 9453375
451500 90300 10158417
473000 94600 9878458
495000 99000 10098250
517500 103500 11883000
540500 108100 12047750
564000 112800 12626917
588000 117600 13515416
612500 122500 13350958
637500 127500 2856708
### **Сравнение алгоритмов сортировки**

| Алгоритм          | Лучший случай (O) | Средний случай (O) | Худший случай (O) | Описание худшего случая                     | Краткое описание работы                                                                 |
|-------------------|-------------------|--------------------|-------------------|---------------------------------------------|-----------------------------------------------------------------------------------------|
| **Merge Sort**    | n log n           | n log n            | n log n           | Всегда стабилен, требует O(n) памяти        | 1. Рекурсивно делит массив пополам. 2. Сливает отсортированные подмассивы.              |
| **Tree Sort**     | n log n           | n log n            | n²                | Уже отсортированный массив                  | 1. Строит бинарное дерево. 2. Обходит inorder.                                         |
run| **Timsort** (2)      | n                 | n log n            | n log n           | Комбинация Merge Sort и Insertion Sort      | 1. Разбивает на подмассивы (run). 2. Сливает с учётом их длины.                        |
корзины| **Bucket Sort** (;)  | n + k             | n + k              | n²                | Элементы в одном ведре                      | 1. Распределяет по ведрам. 2. Сортирует ведра. 3. Объединяет.                         |
rec 2/3| **Stooge Sort**   | n^(log 3/log 1.5) | n^(log 3/log 1.5)  | n^(log 3/log 1.5) | Крайне неэффективен                         | 1. Рекурсивно сортирует 2/3 массива. 2. Повторяет для оставшихся частей.               |
| **Comb Sort**  (gap)   | n log n           | n²                 | n²                | Элементы в обратном порядке                 | 1. Сравнивает элементы с шагом (gap). 2. Уменьшает gap до 1 (как Bubble Sort).         |
куча| **Heapsort**      | n log n           | n log n            | n log n           | Неустойчив, но без худшего случая O(n²)     | 1. Строит max-кучу. 2. Извлекает корень в конец. 3. Перестраивает кучу.               |
куча леонардо| **Smoothsort**  (1)  | n                 | n log n            | n log n           | Адаптивен для почти отсортированных данных  | 1. Использует кучи Леонардо. 2. Комбинирует с HeapSort.                               |
i+1| **Quicksort**     | n log n           | n log n            | n²                | Выбор pivot минимального/максимального      | 1. Выбирает pivot. 2. Разделяет массив. 3. Рекурсивно сортирует части.                |
q->h->i| **Introsort** (3)     | n log n           | n log n            | n log n           | Автоматически переключается на HeapSort     | 1. Начинает с QuickSort. 2. При глубине рекурсии > 2 log n → HeapSort.               |
деление| **Patience Sort** | n log n           | n log n            | n log n           | Использует стеки для сортировки             | 1. Раскладывает элементы по стекам. 2. Объединяет стеки бинарным поиском.            |
| **Shell Sort**  (gap)  | n log n           | зависит от шагов   | n²                | Плохая последовательность шагов             | 1. Сортирует подмассивы с шагом (gap). 2. Уменьшает gap до 1.                        |
разряды| **Radix Sort**    | n * k             | n * k              | n * k             | k — количество разрядов                     | 1. Сортирует поразрядно (от младшего к старшему). 2. Использует Counting Sort.        |
кана | **Topological Sort** | V + E          | V + E              | V + E             | Граф с циклами (невозможно отсортировать)   | 1. Находит вершины без входящих рёбер. 2. Удаляет их и повторяет.                     |

---

### **Ключевые выводы:**
1. **Самые быстрые в среднем**: QuickSort, MergeSort, Timsort, Heapsort (O(n log n)).
2. **Адаптивные алгоритмы**: Timsort, Smoothsort (эффективны для почти отсортированных данных).
3. **Для чисел с малыми разрядами**: Radix Sort (O(n * k)).
4. **Для графов**: Topological Sort (O(V + E)).
5. **Избегайте в продакшене**: Stooge Sort, Comb Sort (крайне медленные).

**Совет:** В Java используйте `Arrays.sort()` (Timsort для объектов, QuickSort-DualPivot для примитивов).

### **Сравнение алгоритмов для работы со строками и графами**

| **Алгоритм**                     | **Лучший случай (O)** | **Средний случай (O)** | **Худший случай (O)** | **Описание худшего случая**                     | **Краткое описание работы** |
|-----------------------------------|-----------------------|------------------------|-----------------------|------------------------------------------------|-----------------------------|
| **Кнута-Морриса-Пратта (KMP)**   | n                    | n + m                 | n + m                | Все символы текста и паттерна одинаковы        | 1. Построение префикс-функции. 2. Поиск с её использованием. |
| **Бойера-Мура**                   | n/m                  | n + m                 | n * m                | Все символы текста и паттерна одинаковы        | 1. Использование таблицы смещений. 2. Сравнение справа налево. |
| **Рабина-Карпа**                  | n + m                | n + m                 | n * m                | Все хеши совпадают, но строки разные           | 1. Вычисление хешей. 2. Сравнение хешей и строк. |

| **Поиск в ширину (BFS)**          | V + E                | V + E                 | V + E                | Полный обход графа                             | 1. Очередь для посещения вершин. 2. Поуровневый обход. |
| **Поиск в глубину (DFS)**         | V + E                | V + E                 | V + E                | Полный обход графа                             | 1. Рекурсивный обход. 2. Использование стека. |

| **Флойда-Уоршелла**               | V³                   | V³                    | V³                   | Плотный граф                                   | 1. Динамическое программирование. 2. Тройной цикл по вершинам. |
| **Беллмана-Форда**                | V * E                | V * E                 | V * E                | Граф с отрицательными циклами                  | 1. Релаксация рёбер. 2. Проверка на отрицательные циклы. |
| **Левита**                        | V * E                | V * E                 | V * E                | Граф с отрицательными рёбрами                  | 1. Использование очередей для вершин. 2. Оптимизация через приоритеты. |

| **Дейкстры**                      | V + E log V          | V + E log V           | V + E log V          | Граф без отрицательных рёбер                   | 1. Приоритетная очередь. 2. Жадный выбор вершин. |
| **Краскала**                      | E log E              | E log E               | E log E              | Плотный граф                                   | 1. Сортировка рёбер. 2. Объединение множеств (DSU). |

| **Прима**                         | E + V log V          | E + V log V           | E + V log V          | Плотный граф                                   | 1. Жадный выбор рёбер. 2. Использование кучи. |
| **Грэхема**                       | n log n              | n log n               | n log n              | Все точки на одной прямой                      | 1. Сортировка по углу. 2. Построение оболочки через стек. |
| **Джарвиса**                      | n * h                | n * h                 | n²                   | Все точки входят в оболочку (h = n)            | 1. Поиск точек с минимальным углом. 2. Пошаговое построение. |
| **Чана**                          | n log h              | n log h               | n log h              | Все точки на одной прямой                      | 1. Рекурсивное разбиение. 2. Построение оболочки для подмножеств. |

### **Ключевые выводы:**
1. **Для поиска подстрок**:
   - **KMP** — надёжный, но сложный в реализации.
   - **Бойера-Мура** — быстрый на практике, но зависит от алфавита.
   - **Рабина-Карпа** — простой, но требует аккуратной работы с хешами.

2. **Для обхода графов**:
   - **BFS** — оптимален для поиска кратчайших путей в невзвешенных графах.
   - **DFS** — полезен для топологической сортировки и поиска компонент связности.

3. **Для кратчайших путей**:
   - **Дейкстра** — быстрый, но только для неотрицательных рёбер.
   - **Беллман-Форд** — работает с отрицательными рёбрами, но медленнее.
   - **Флойд-Уоршелл** — для всех пар вершин, но O(V³).

4. **Для минимального остовного дерева**:
   - **Краскал** — проще, но требует сортировки рёбер.
   - **Прим** — быстрее на плотных графах.

5. **Для выпуклой оболочки**:
   - **Грэхем** — эффективен в большинстве случаев.
   - **Джарвис** — проще, но медленнее при большом h.
   - **Чан** — баланс между скоростью и сложностью.

**Совет:**
Выбор алгоритма зависит от структуры данных и конкретной задачи.
Например, для поиска подстрок в тексте предпочтительнее Бойера-Мура,
а для кратчайших путей во взвешенных графах — Дейкстра или Беллман-Форд. 🚀
